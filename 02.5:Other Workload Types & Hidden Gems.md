‚ö° Phase 2.5: Other Workload Types & Hidden Gems

---

üìò Concepts

- 1.ReplicationController (RC) ‚Äì Legacy
- First workload controller in Kubernetes.
- Ensures a specified number of Pod replicas are running.
- Replaced by ReplicaSet, but still supported for backward compatibility.
- Difference vs ReplicaSet:
  - RC supports only equality-based selectors (env=dev).
  - RS supports set-based selectors (env in (dev, qa)).
üîπ Example (ReplicationController YAML)
```bash
apiVersion: v1
kind: ReplicationController
metadata:
  name: nginx-rc
spec:
  replicas: 2
  selector:
    app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.25
        ports:
        - containerPort: 80
```

---

- 2.DaemonSet
- Ensures one Pod per Node (or per subset of Nodes).
- Common use cases:
  - Logging agents (Fluentd).
  - Monitoring agents (Prometheus Node Exporter).
  - Network plugins (Calico, Cilium, Weave).
- If new Node joins ‚Üí DaemonSet auto-creates Pod on it.
üîπ Example (DaemonSet YAML)
```bash
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: log-agent
  labels:
    app: log-agent
spec:
  selector:
    matchLabels:
      app: log-agent
  template:
    metadata:
      labels:
        app: log-agent
    spec:
      containers:
      - name: fluentd
        image: fluent/fluentd:v1.16
```

---

- 3.Static Pods
- Pods created directly by Kubelet, not API Server.
- YAMLs placed in /etc/kubernetes/manifests/ (by default).
- Used for control plane components in self-managed clusters (API Server, etcd, Scheduler).
- Managed locally on the node ‚Üí API Server just mirrors them (you can see them but not delete via kubectl).

---

- 4.Networking Primer (CNI Basics)
- Each Pod gets a unique IP (from cluster network range).
- Pods across Nodes communicate via a CNI plugin (Flannel, Calico, Cilium).
- Services provide stable DNS names so you don‚Äôt hardcode Pod IPs.
- Example:
  - Pod A ‚Üí curl http://backend-service:8080
  - DNS automatically resolves backend-service to the correct Pod(s)

---

- 5.Downward API
- Lets Pods access their own metadata (name, namespace, labels).
üîπ Example (inject Pod name as env var)
```bash
env:
- name: POD_NAME
  valueFrom:
    fieldRef:
      fieldPath: metadata.name
```

---

üõ†Ô∏è Mini Project

- Goal: Build a monitoring-ready cluster setup
  - Deploy a DaemonSet running Fluentd for logging.
  - Deploy a Deployment with labels (app=frontend, env=dev).
  - Expose labels inside the Pod using Downward API.
  - Create a ReplicationController (for legacy practice).
  - Verify Pods across all Nodes (kubectl get pods -o wide).

---

üß† Interview Tips

‚ùì Q1: What‚Äôs the difference between ReplicationController and ReplicaSet?

- Short:
  - RC = legacy, only equality-based selectors.
  - RS = modern, supports set-based selectors.

- Expanded:
  - ReplicationController ensures a specified number of Pods are running. It only supports equality-based selectors (e.g., env=dev).
  - ReplicaSet is the modern replacement. It supports set-based selectors (e.g., env in (dev, qa)), making it more flexible.
  - Deployments always use ReplicaSets internally.
  - RC is mostly obsolete, but interviewers may ask it for legacy awareness.

  ---

  ‚ùì Q2: Why do we need DaemonSets? Give real-world examples.

- Short:
  - DaemonSets ensure one Pod per Node, often for cluster-wide agents.

- Expanded:
  - DaemonSet guarantees that every Node (or selected Nodes) runs exactly one instance of a Pod.
  - Useful for deploying node-level services like:
  - Logging agents (Fluentd, Filebeat).
  - Monitoring agents (Prometheus Node Exporter, Datadog Agent).
  - Networking components (Calico, Cilium).
  - When a new Node joins the cluster, the DaemonSet automatically deploys the Pod on it.

---

‚ùì Q3: What are Static Pods? Why are they important for control plane?

- Short:
  - Static Pods are created by kubelet, not API Server.
  - Used for control plane components.

- Expanded:
  - Static Pods are defined by YAML files placed directly on a Node (default: /etc/kubernetes/manifests/).
  - They are managed by the kubelet, bypassing the API Server.
  - The API Server only shows a ‚Äúmirror Pod‚Äù copy (you can see but not manage it).
  - They‚Äôre crucial for bootstrapping control plane: etcd, API Server, Controller Manager, Scheduler often run as static Pods in kubeadm clusters.

  ---

  ‚ùì Q4: How do Pods get IP addresses across nodes?

- Short:
  - Kubernetes uses a CNI plugin to assign Pod IPs from a cluster-wide range.

- Expanded:
  - Each Pod gets its own unique IP address (not shared with the Node).
  - Kubernetes itself doesn‚Äôt do networking ‚Äî it relies on a CNI (Container Network Interface) plugin (Flannel, Calico, Cilium, Weave).
  - CNI ensures that:
    - Pod IPs are routable across nodes.
    - All Pods can communicate with each other by default (‚Äúflat network‚Äù).
  - Services + CoreDNS provide stable names so you don‚Äôt rely on Pod IPs directly.

  ---

  ‚ùì Q5: What is Downward API used for?

- Short:
  - Expose Pod metadata (name, labels, namespace, resource requests/limits) inside containers.

- Expanded:
  - Downward API lets you inject Kubernetes object fields into a Pod at runtime, without hardcoding them.
  - You can pass this data as:
  - Environment variables
  - Mounted files
  - Examples:
    - Inject Pod name/namespace into logs (POD_NAME, POD_NAMESPACE).
    - Pass labels/annotations to app config.
    - Expose resource requests/limits inside the container.
- Real-world use: telemetry, logging, and auto-discovery setups.

---

üîë Hidden Gems

- Control plane runs as Static Pods in most kubeadm clusters.
- kubectl get ds -A ‚Üí view all DaemonSets (you‚Äôll always see networking + monitoring agents).
- Downward API + ConfigMap combo = powerful dynamic config injection.
- RC is mostly dead ‚Üí but interviewers love to test legacy knowledge.

---

üè° Homework (5 Tasks)

- Create a ReplicationController for Nginx with 2 replicas.
- Deploy a DaemonSet that runs a busybox container on every Node.
- Use Downward API to expose Pod name and namespace as env vars.
- Verify Static Pods exist in kube-system namespace on your cluster.
- Describe how Pod networking works in your cluster:
  - Run kubectl get pods -o wide ‚Üí note Pod IPs.
  - Test connectivity between Pods across namespaces.